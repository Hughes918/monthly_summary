<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Monthly Summary Sandbox</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f9fa;
      margin: 0;
      padding: 0;
    }
    h1 {
      text-align: center;
      margin-top: 30px;
      color: #2c3e50;
    }
    .controls {
      margin: 30px auto 0 auto;
      padding: 20px 30px 10px 30px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      max-width: 1100px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px 20px;
    }
    .controls label {
      font-weight: 500;
      color: #34495e;
      margin-bottom: 0;
    }
    .controls input[type="text"], .controls select {
      padding: 7px 10px;
      border: 1px solid #bfc9d1;
      border-radius: 4px;
      font-size: 1em;
      background: #fafdff;
      min-width: 120px;
      margin-bottom: 0;
    }
    .controls button {
      background: #3498db;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 9px 20px;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      margin-bottom: 0;
      transition: background 0.2s;
    }
    .controls button:disabled {
      background: #bfc9d1;
      color: #fff;
      cursor: not-allowed;
    }
    .controls button:not(:last-child) {
      margin-right: 8px;
    }
    .controls button:hover:not(:disabled) {
      background: #217dbb;
    }
    #paramContainer label {
      margin-right: 5px;
    }
    #paramContainer select {
      margin-right: 15px;
    }
    .error {
      color: #c0392b;
      margin: 20px auto 0 auto;
      max-width: 900px;
      font-weight: 500;
      text-align: center;
    }
    table {
      border-collapse: collapse;
      width: 95%;
      margin: 30px auto 0 auto;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    }
    th, td {
      border: 1px solid #e1e8ed;
      padding: 10px 8px;
      text-align: left;
      font-size: 1em;
    }
    th {
      background-color: #f3f7fa;
      color: #34495e;
      font-weight: 600;
    }
    tr:nth-child(even) td {
      background: #f9fbfc;
    }
    /* Simple hover tooltip for score histories */
    .tooltip-wrap { position: relative; display: inline-block; }
    .tooltip-content {
      display: none;
      position: absolute;
      z-index: 9999;
      top: 120%;
      left: 0;
      min-width: 220px;
      max-width: 320px;
      max-height: 260px;
      overflow: auto;
      padding: 10px;
      border: 1px solid #e1e8ed;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      color: #2c3e50;
      font-size: 12px;
      line-height: 1.4;
      white-space: nowrap;
    }
    .tooltip-wrap:hover .tooltip-content { display: block; }
  </style>
</head>
<body>
  <h1>DAGF — Mean Daily Barometric Pressure (Last 30 Days)</h1>
  <div class="controls" style="max-width:950px;justify-content:flex-start;gap:12px 16px;">
    <label for="startDateInput">Start Date:</label>
    <input type="date" id="startDateInput" />
    <button id="applyRangeBtn">Run</button>
    <div style="font-size:0.95em;color:#566;">Leave blank to use the most recent 30 days.</div>
  </div>
  <div id="errorMsg" class="error"></div>
  <div id="loadingSpinner" style="display:none;text-align:center;margin-top:20px;">
    <svg width="48" height="48" viewBox="0 0 50 50">
      <circle cx="25" cy="25" r="20" fill="none" stroke="#3498db" stroke-width="5" stroke-linecap="round" stroke-dasharray="31.4 31.4" transform="rotate(-90 25 25)">
        <animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="1s" repeatCount="indefinite"/>
      </circle>
    </svg>
    <div style="color:#3498db;font-weight:500;margin-top:8px;">Loading...</div>
  </div>
  <div id="graphContainer" style="display:none;max-width:95%;margin:0 auto 20px auto;">
    <div id="graphActions" style="display:flex;align-items:center;justify-content:flex-end;margin-bottom:8px;"></div>
    <canvas id="resultsChart"></canvas>
  </div>
  <div id="statsContainer" style="display:none;max-width:95%;margin:0 auto 20px auto;"></div>
  <div id="qcContainer" style="display:none;max-width:95%;margin:0 auto 40px auto;"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    /* ===== Render chart instantly: disable all Chart.js animations ===== */
    if (window.Chart && Chart.defaults) {
      Chart.defaults.animation = false;
      if (Chart.defaults.transitions && Chart.defaults.transitions.active) {
        Chart.defaults.transitions.active.animation = false;
      }
    }

    // Configuration for this page
    const STATIONS = ['DAGF','DBKB','DBLK','DBNG','DBRG','DCHI','DCLY','DDFS','DFHM','DGES',
'DGLW','DGUM','DHAR','DHOC','DJCR','DLAU','DMIL','DNEM','DNOT','DPPN',
'DRHB','DSCR','DSGM','DSJR','DSLB','DSND','DTDF','DWAR','DWBD','DWCH',
'DWHW','DWPK','DWWK'];
    const DATA_TYPE_ID = '285'; //285=min, 284=max, 283=mean Mean Daily Barometric Pressure
    const DAYS_BACK = 30; // default window length in days

    function buildProcessUrl(station, dataType, year, month) {
      return `process.php?station=${station}&dataType=${dataType}&startYear=${year}&endYear=${year}&month=${month}`;
    }

    function showSpinner() {
      document.getElementById("loadingSpinner").style.display = "";
    }
    function hideSpinner() {
      document.getElementById("loadingSpinner").style.display = "none";
    }

    let lastSeries = null; // { [station]: array<{date, value}> }
    let lastLabels = null; // array of dates aligned to lastSeries entries
    let paramMeta = { label: 'Mean Daily Barometric Pressure', units: 'mb' };
    let chartInstance = null;
    let stationQC = {}; // station -> { category, score }
    let stationScoreHistory = {}; // station -> [{ date, score }] (per-day scores used in QC)
    let fullDateMapByStation = {}; // station -> Map(dateStr -> value) for extended range

    function clearGraph() {
      document.getElementById("graphContainer").style.display = "none";
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }
    }
    function clearStats() {
      document.getElementById("statsContainer").style.display = "none";
      document.getElementById("statsContainer").innerHTML = "";
    }
    // Compute date helpers
    function formatDate(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function monthsInRange(start, end) {
      const months = [];
      const cur = new Date(start.getFullYear(), start.getMonth(), 1);
      const endAnchor = new Date(end.getFullYear(), end.getMonth(), 1);
      while (cur <= endAnchor) {
        months.push({ year: cur.getFullYear(), month: String(cur.getMonth() + 1).padStart(2, '0') });
        cur.setMonth(cur.getMonth() + 1);
      }
      return months;
    }

    function getDateRange() {
      const today = new Date();
      today.setHours(0,0,0,0);
      const input = document.getElementById('startDateInput');
      const val = input && input.value ? new Date(input.value) : null;
      if (val && !isNaN(val.getTime())) {
        const start = new Date(val.getFullYear(), val.getMonth(), val.getDate());
        const end = new Date(start);
        end.setDate(start.getDate() + (DAYS_BACK - 1));
        return { start, end };
      } else {
        const end = new Date(today);
        const start = new Date(end);
        start.setDate(end.getDate() - (DAYS_BACK - 1));
        return { start, end };
      }
    }

    async function fetchLast30Days() {
      const errorMsg = document.getElementById("errorMsg");
      errorMsg.textContent = "";
      clearGraph();
      clearStats();
      showSpinner();

      // Range (either entered start date or last DAYS_BACK days)
      const { start, end } = getDateRange();

      // Lookup param meta (label/units)
      try {
        const plist = await fetch('parameters.json').then(r => r.json());
        const meta = plist.find(p => String(p.data_type_id) === DATA_TYPE_ID);
        if (meta) {
          paramMeta = { label: meta.display_name, units: meta.display_units };
          // Update H1 with units if present
          const h1 = document.querySelector('h1');
          if (h1) {
            const rangeTxt = `${formatDate(start)} to ${formatDate(end)}`;
            h1.textContent = `${STATIONS.join(', ')} — ${paramMeta.label} (${paramMeta.units}) — ${rangeTxt}`;
          }
        }
      } catch (_) { /* non-fatal */ }
      // Fetch extended range (previous DAYS_BACK days) to compute rolling-30 scores
      const extStart = new Date(start);
      extStart.setDate(extStart.getDate() - DAYS_BACK);
      const months = monthsInRange(extStart, end);

      // Fetch data for all stations in parallel
      const stationData = await Promise.all(
        STATIONS.map(async (station) => {
          const maps = await Promise.all(months.map(async (m) => {
            const url = buildProcessUrl(station, DATA_TYPE_ID, m.year, m.month);
            try {
              const text = await fetch(url).then(r => r.text());
              const data = text ? JSON.parse(text) : { results: [] };
              return Array.isArray(data.results) ? data.results : [];
            } catch (e) {
              // Non-fatal; return empty set for this month
              return [];
            }
          }));
          // Flatten and build date->value map
          const map = new Map();
          maps.flat().forEach(item => {
            const dstr = (item.date || '').slice(0, 10);
            if (!dstr) return;
            map.set(dstr, item.value);
          });
          return { station, map };
        })
      );

      // Build aligned date labels and per-station series
      const labels = [];
      const seriesByStation = {};
      const cursor = new Date(start);
      while (cursor <= end) {
        const dstr = formatDate(cursor);
        labels.push(dstr);
        cursor.setDate(cursor.getDate() + 1);
      }
      const fullMaps = {};
      for (const { station, map } of stationData) {
        seriesByStation[station] = labels.map(dstr => {
          let v = map.has(dstr) ? map.get(dstr) : "--";
          if (v !== "--" && v !== null && v !== undefined && !isNaN(v)) {
            v = Number(v);
          } else {
            v = "--";
          }
          return { date: dstr, value: v };
        });
        fullMaps[station] = map; // keep extended map for rolling windows
      }

      lastLabels = labels;
      lastSeries = seriesByStation;
      fullDateMapByStation = fullMaps;
      hideSpinner();
      renderStats();
      renderQualityChecks();
      renderGraph();
    }

    function renderStats() {
      const statsDiv = document.getElementById("statsContainer");
      statsDiv.innerHTML = "";
      if (!lastSeries || Object.keys(lastSeries).length === 0) {
        statsDiv.style.display = "";
        statsDiv.innerHTML = "<div style='color:#c0392b;font-weight:500;'>No data found.</div>";
        return;
      }
      let html = "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);margin-bottom:30px;'>";
      html += "<thead><tr>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station / Parameter</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Count</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Missing</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Min</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Mean</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Max</th>";
      html += "</tr></thead><tbody>";
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        const nums = series.map(d => d.value).filter(v => v !== "--" && !isNaN(v));
        const count = nums.length;
        const missing = series.length - count;
        let min = "--", max = "--", mean = "--";
        if (count > 0) {
          min = Math.min(...nums);
          max = Math.max(...nums);
          mean = (nums.reduce((a, b) => a + b, 0) / count).toFixed(2);
        }
        const label = `${station}: ${paramMeta.label} (${paramMeta.units})`;
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${label}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${count}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${missing}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${min}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${mean}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${max}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      statsDiv.style.display = "";
      statsDiv.innerHTML = html;
    }

    function renderGraph() {
      if (!lastSeries || !lastLabels || Object.keys(lastSeries).length === 0) return;
      const labels = lastLabels;
      const ctx = document.getElementById('resultsChart').getContext('2d');
      clearGraph();

      function colorForCategory(cat) {
        switch (cat) {
          case 'Minimal concern': return '#f1c40f'; // yellow
          case 'Possible concern': return '#f39c12'; // orange
          case 'Potential issue': return '#e74c3c'; // red
          default: return '#bfc9d1'; // light grey
        }
      }

      const datasets = STATIONS.map((station) => {
        const series = lastSeries[station] || [];
        const data = series.map(d => (d.value === "--" || isNaN(d.value)) ? null : Number(d.value));
        const cat = (stationQC[station] && stationQC[station].category) ? stationQC[station].category : 'No concern';
        const color = colorForCategory(cat);
        return {
          label: station,
          data,
          borderColor: color,
          backgroundColor: color + '33',
          spanGaps: false,
          pointRadius: 2,
          tension: 0.2
        };
      });
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
          responsive: true,
          animation: false,
          plugins: {
            legend: { display: true, position: 'top' },
            title: { display: false }
          },
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: { display: true, title: { display: true, text: 'Date' } },
            y: { display: true, title: { display: true, text: paramMeta.units || 'Value' } }
          }
        }
      });
      document.getElementById("graphContainer").style.display = "";
    }

    // Allow manual range application
    document.getElementById('applyRangeBtn').addEventListener('click', () => {
      fetchLast30Days();
    });

    // Auto-run on load
    window.addEventListener('DOMContentLoaded', fetchLast30Days);

    // ===== Quality Control Rendering =====
    function scoreCategory(score) {
      if (score >= 90) return 'No concern';
      if (score >= 80) return 'Minimal concern';
      if (score >= 70) return 'Possible concern';
      return 'Potential issue';
    }

    

    function mean(arr) { return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }
    function stddev(arr) {
      if (arr.length < 2) return 0;
      const m = mean(arr);
      const v = arr.reduce((s,x)=>s+(x-m)*(x-m),0)/(arr.length-1);
      return Math.sqrt(v);
    }
    function median(arr) {
      const a = arr.filter(v => v !== null && !isNaN(v)).slice().sort((x,y)=>x-y);
      const n = a.length;
      if (!n) return NaN;
      const mid = Math.floor(n/2);
      return n % 2 ? a[mid] : (a[mid-1] + a[mid]) / 2;
    }

    function renderQualityChecks() {
      const container = document.getElementById('qcContainer');
      container.innerHTML = '';
      if (!lastSeries || !lastLabels) { container.style.display = 'none'; return; }

      // Build station -> numeric array aligned to labels (null for missing)
      const stationNums = {};
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        stationNums[station] = series.map(d => (d && d.value !== "--" && !isNaN(d.value)) ? Number(d.value) : null);
      }


      // Compute SD-based comparison stats per station
      const test1 = {}; // station -> {meanStation, meanPeers, nDays, avgAbsDiff, avgZ}
      for (const station of STATIONS) {
        let sumAbs = 0; let nDays = 0; let sumStation = 0; let sumPeers = 0; let nPeersDays = 0;
        let sumZ = 0; let nZ = 0;
        for (let i = 0; i < lastLabels.length; i++) {
          const vi = stationNums[station][i];
          if (vi === null) continue; // only evaluate on days with station value
          const peers = [];
          for (const s2 of STATIONS) {
            if (s2 === station) continue;
            const v2 = stationNums[s2][i];
            if (v2 !== null) peers.push(v2);
          }
          if (peers.length === 0) continue; // need at least one peer that day
          const mPeers = mean(peers);
          const sPeers = stddev(peers);
          const diff = Math.abs(vi - mPeers);
          sumAbs += diff;
          nDays++;
          sumStation += vi;
          sumPeers += mPeers;
          nPeersDays++;
          if (sPeers > 0) { sumZ += diff / sPeers; nZ++; }
        }
        const meanStation = nDays > 0 ? sumStation / nDays : 0;
        const meanPeers = nPeersDays > 0 ? sumPeers / nPeersDays : 0;
        const avgAbsDiff = nDays > 0 ? (sumAbs / nDays) : 0;
        const avgZ = nZ > 0 ? (sumZ / nZ) : 0;
        test1[station] = { meanStation, meanPeers, nDays, avgAbsDiff, avgZ };
      }

      // Legacy backfill removed; test now uses SD-based metrics directly.

   

      // Build table
      let html = "<h2 style='color:#2c3e50;margin:10px 0 10px 0;'>Quality Control</h2>";
      html += "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);'>";
      html += "<thead><tr>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>StdDev Score</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>StdDev Detail</th>"+
              
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Overall</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Category</th>"+
              "</tr></thead><tbody>";

      function scoreBadge(score) {
        let bg = '#2ecc71'; // green
        if (score < 70) bg = '#e74c3c';
        else if (score < 80) bg = '#f39c12';
        else if (score < 90) bg = '#f1c40f';
        return `<span style="display:inline-block;padding:4px 8px;border-radius:12px;color:#fff;background:${bg};min-width:38px;text-align:center;">${score}</span>`;
      }

      for (const station of STATIONS) {
        const t1 = test1[station];
        // SD-based scoring: average of per-day scores derived from peer mean/SD
        let score1 = 0; // will be computed below
        const avgDetail = `mean=${t1.meanStation.toFixed(2)} ${paramMeta.units}, overall=${t1.meanAll.toFixed(2)} ${paramMeta.units}, Δ=${t1.delta.toFixed(2)} ${paramMeta.units}, n=${t1.n}`;

      
        const overall = score1;
        const cat = scoreCategory(overall);
        stationQC[station] = { category: cat, score: overall };
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${station}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${scoreBadge(score1)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${avgDetail}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;font-weight:600;'>${scoreBadge(overall)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${cat}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      container.innerHTML = html;
      container.style.display = '';
    }

    // Override with SD-based QC scoring per spec
    function renderQualityChecks() {
      const container = document.getElementById('qcContainer');
      container.innerHTML = '';
      if (!lastSeries || !lastLabels) { container.style.display = 'none'; return; }

      const stationNums = {};
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        stationNums[station] = series.map(d => (d && d.value !== "--" && !isNaN(d.value)) ? Number(d.value) : null);
      }

      const test1 = {};
      for (const station of STATIONS) {
        let sumAbs = 0; let nDays = 0; let sumStation = 0; let sumPeers = 0; let nPeersDays = 0;
        let sumZ = 0; let nZ = 0;
        for (let i = 0; i < lastLabels.length; i++) {
          const vi = stationNums[station][i];
          if (vi === null) continue;
          const peers = [];
          for (const s2 of STATIONS) {
            if (s2 === station) continue;
            const v2 = stationNums[s2][i];
            if (v2 !== null) peers.push(v2);
          }
          if (peers.length === 0) continue;
          const mPeers = mean(peers);
          const sPeers = stddev(peers);
          const diff = Math.abs(vi - mPeers);
          sumAbs += diff;
          nDays++;
          sumStation += vi;
          sumPeers += mPeers;
          nPeersDays++;
          if (sPeers > 0) { sumZ += diff / sPeers; nZ++; }
        }
        const meanStation = nDays > 0 ? sumStation / nDays : 0;
        const meanPeers = nPeersDays > 0 ? sumPeers / nPeersDays : 0;
        const avgAbsDiff = nDays > 0 ? (sumAbs / nDays) : 0;
        const avgZ = nZ > 0 ? (sumZ / nZ) : 0;
        test1[station] = { meanStation, meanPeers, nDays, avgAbsDiff, avgZ };
      }

      function scoreFromDiffAndSD(diff, s) {
        if (diff <= 1) return 100;
        if (!isFinite(s) || s <= 0) return 40;
        const z = diff / s;
        if (z <= 1) return 100;
        if (z <= 2) return Math.round(100 - 10 * (z - 1));
        if (z <= 5) return Math.round(100 - 30 * (z - 2));
        return 0;
      }

      let html = "<h2 style='color:#2c3e50;margin:10px 0 10px 0;'>Quality Control</h2>";
      html += "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);'>";
      html += "<thead><tr>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>StdDev Score</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>StdDev Detail</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Trend</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Category</th>"+
              "</tr></thead><tbody>";

      function scoreBadge(score) {
        let bg = '#2ecc71';
        if (score < 70) bg = '#e74c3c';
        else if (score < 80) bg = '#f39c12';
        else if (score < 90) bg = '#f1c40f';
        return `<span style=\"display:inline-block;padding:4px 8px;border-radius:12px;color:#fff;background:${bg};min-width:38px;text-align:center;\">${score}</span>`;
      }

      function trendBadge(delta) {
        const sign = delta > 0 ? '+' : (delta < 0 ? '' : '');
        const arrow = delta > 0 ? '↑' : (delta < 0 ? '↓' : '→');
        let bg = '#bfc9d1'; // neutral
        if (delta > 0) bg = '#2ecc71';
        if (delta < 0) bg = '#e74c3c';
        return `<span style="display:inline-block;padding:4px 8px;border-radius:12px;color:#fff;background:${bg};min-width:56px;text-align:center;">${arrow} ${sign}${Math.round(delta)}</span>`;
      }

      function buildSparklineSVG(history) {
        const w = 220, h = 40, pad = 2;
        const n = (history && history.length) ? history.length : 0;
        if (n <= 1) return '<div>No trend available</div>';
        const xs = [];
        const ys = [];
        const stepX = (w - 2*pad) / (n - 1);
        for (let i = 0; i < n; i++) {
          const x = pad + i * stepX;
          const v = Math.max(0, Math.min(100, Number(history[i].score) || 0));
          const y = pad + (h - 2*pad) * (1 - v/100);
          xs.push(x); ys.push(y);
        }
        let d = `M ${xs[0].toFixed(1)} ${ys[0].toFixed(1)}`;
        for (let i = 1; i < n; i++) d += ` L ${xs[i].toFixed(1)} ${ys[i].toFixed(1)}`;
        const area = `${d} L ${xs[n-1].toFixed(1)} ${(h-pad).toFixed(1)} L ${xs[0].toFixed(1)} ${(h-pad).toFixed(1)} Z`;
        const cx = xs[n-1].toFixed(1), cy = ys[n-1].toFixed(1);
        return `
          <svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
            <path d="${area}" fill="#3498db22" stroke="none"></path>
            <path d="${d}" fill="none" stroke="#3498db" stroke-width="2" stroke-linecap="round" />
            <circle cx="${cx}" cy="${cy}" r="2.8" fill="#3498db" />
          </svg>
        `;
      }

      // Helper to build tooltip HTML from a score history
      function buildTooltipContent(history) {
        if (!history || history.length === 0) return '<div>No per-day scores</div>';
        const spark = buildSparklineSVG(history);
        const last = history[history.length - 1];
        const first = history[0];
        const delta = (Number(last.score) || 0) - (Number(first.score) || 0);
        const sign = delta > 0 ? '+' : (delta < 0 ? '' : '');
        return `
          <div style="font-weight:600;margin-bottom:6px;">Trend (last ${history.length} days)</div>
          ${spark}
          <div style="margin-top:6px;color:#566;">Start: <strong>${first.score}</strong> → Now: <strong>${last.score}</strong> (${sign}${Math.round(delta)})</div>
        `;
      }

      for (const station of STATIONS) {
        const t1 = test1[station];
        const dailyScores = [];
        const dailyHistory = [];
        // For each displayed day, compute score as the average of
        // per-day peer-difference scores across the previous 30 days
        for (let i = 0; i < lastLabels.length; i++) {
          const curDate = new Date(lastLabels[i]);
          const windowScores = [];
          for (let k = 1; k <= DAYS_BACK; k++) {
            const d = new Date(curDate);
            d.setDate(curDate.getDate() - k);
            const dstr = formatDate(d);
            // Pull station value for dstr from extended map
            const mapSelf = fullDateMapByStation[station];
            if (!mapSelf) continue;
            let vi = mapSelf.has(dstr) ? mapSelf.get(dstr) : null;
            if (vi === null || vi === undefined || isNaN(vi)) continue;
            vi = Number(vi);
            const peers = [];
            for (const s2 of STATIONS) {
              if (s2 === station) continue;
              const map2 = fullDateMapByStation[s2];
              if (!map2) continue;
              let v2 = map2.has(dstr) ? map2.get(dstr) : null;
              if (v2 !== null && v2 !== undefined && !isNaN(v2)) peers.push(Number(v2));
            }
            if (peers.length === 0) continue;
            const mPeers = mean(peers);
            const sPeers = stddev(peers);
            const diff = Math.abs(vi - mPeers);
            windowScores.push(scoreFromDiffAndSD(diff, sPeers));
          }
          const dayScore = windowScores.length ? Math.round(mean(windowScores)) : 0;
          dailyScores.push(dayScore);
          dailyHistory.push({ date: lastLabels[i], score: dayScore });
        }
        const score1 = dailyScores.length ? Math.round(mean(dailyScores)) : 0;
        const currentScore = dailyScores.length ? dailyScores[dailyScores.length - 1] : 0;
        const avgDetail = `mean=${t1.meanStation.toFixed(2)} ${paramMeta.units}, peers=${t1.meanPeers.toFixed(2)} ${paramMeta.units}, avg|diff|=${t1.avgAbsDiff.toFixed(2)} ${paramMeta.units}, avgZ=${t1.avgZ.toFixed(2)}, days=${t1.nDays}`;

        const overall = currentScore;
        const cat = scoreCategory(overall);
        stationQC[station] = { category: cat, score: overall };
        // Store per-day score history for hover tooltip
        stationScoreHistory[station] = dailyHistory;
        const tooltipHtml = buildTooltipContent(dailyHistory);
        // Compute trend vs exactly 30 days prior to end-date
        const endDateStr = lastLabels[lastLabels.length - 1];
        const endDate = new Date(endDateStr);
        const prevDate = new Date(endDate);
        prevDate.setDate(endDate.getDate() - 30);
        const prevDateStr = formatDate(prevDate);
        function rollingScoreForDate(stn, dateStr) {
          const cur = new Date(dateStr);
          const windowScores = [];
          for (let k = 1; k <= DAYS_BACK; k++) {
            const d = new Date(cur);
            d.setDate(cur.getDate() - k);
            const dstr = formatDate(d);
            const mapSelf = fullDateMapByStation[stn];
            if (!mapSelf) continue;
            let vi = mapSelf.has(dstr) ? mapSelf.get(dstr) : null;
            if (vi === null || vi === undefined || isNaN(vi)) continue;
            vi = Number(vi);
            const peers = [];
            for (const s2 of STATIONS) {
              if (s2 === stn) continue;
              const map2 = fullDateMapByStation[s2];
              if (!map2) continue;
              let v2 = map2.has(dstr) ? map2.get(dstr) : null;
              if (v2 !== null && v2 !== undefined && !isNaN(v2)) peers.push(Number(v2));
            }
            if (peers.length === 0) continue;
            const mPeers = mean(peers);
            const sPeers = stddev(peers);
            const diff = Math.abs(vi - mPeers);
            windowScores.push(scoreFromDiffAndSD(diff, sPeers));
          }
          return windowScores.length ? Math.round(mean(windowScores)) : null;
        }
        const prevScore = rollingScoreForDate(station, prevDateStr);
        const trendDelta = (prevScore === null) ? null : (currentScore - prevScore);
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${station}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>
            <span class="tooltip-wrap">${scoreBadge(currentScore)}
              <div class="tooltip-content">${tooltipHtml}</div>
            </span>
          </td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${avgDetail}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;font-weight:600;'>${trendDelta === null ? '--' : trendBadge(trendDelta)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${cat}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      container.innerHTML = html;
      container.style.display = '';
    }
  </script>
</body>
</html>
