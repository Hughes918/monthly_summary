<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Monthly Summary Sandbox</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f9fa;
      margin: 0;
      padding: 0;
    }
    h1 {
      text-align: center;
      margin-top: 30px;
      color: #2c3e50;
    }
    .controls {
      margin: 30px auto 0 auto;
      padding: 20px 30px 10px 30px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      max-width: 1100px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px 20px;
    }
    .controls label {
      font-weight: 500;
      color: #34495e;
      margin-bottom: 0;
    }
    .controls input[type="text"], .controls select {
      padding: 7px 10px;
      border: 1px solid #bfc9d1;
      border-radius: 4px;
      font-size: 1em;
      background: #fafdff;
      min-width: 120px;
      margin-bottom: 0;
    }
    .controls button {
      background: #3498db;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 9px 20px;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      margin-bottom: 0;
      transition: background 0.2s;
    }
    .controls button:disabled {
      background: #bfc9d1;
      color: #fff;
      cursor: not-allowed;
    }
    .controls button:not(:last-child) {
      margin-right: 8px;
    }
    .controls button:hover:not(:disabled) {
      background: #217dbb;
    }
    #paramContainer label {
      margin-right: 5px;
    }
    #paramContainer select {
      margin-right: 15px;
    }
    .error {
      color: #c0392b;
      margin: 20px auto 0 auto;
      max-width: 900px;
      font-weight: 500;
      text-align: center;
    }
    table {
      border-collapse: collapse;
      width: 95%;
      margin: 30px auto 0 auto;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    }
    th, td {
      border: 1px solid #e1e8ed;
      padding: 10px 8px;
      text-align: left;
      font-size: 1em;
    }
    th {
      background-color: #f3f7fa;
      color: #34495e;
      font-weight: 600;
    }
    tr:nth-child(even) td {
      background: #f9fbfc;
    }
  </style>
</head>
<body>
  <h1>DAGF — Mean Daily Barometric Pressure (Last 30 Days)</h1>
  <div class="controls" style="max-width:950px;justify-content:flex-start;gap:12px 16px;">
    <label for="startDateInput">Start Date:</label>
    <input type="date" id="startDateInput" />
    <button id="applyRangeBtn">Run</button>
    <div style="font-size:0.95em;color:#566;">Leave blank to use the most recent 30 days.</div>
  </div>
  <div id="errorMsg" class="error"></div>
  <div id="loadingSpinner" style="display:none;text-align:center;margin-top:20px;">
    <svg width="48" height="48" viewBox="0 0 50 50">
      <circle cx="25" cy="25" r="20" fill="none" stroke="#3498db" stroke-width="5" stroke-linecap="round" stroke-dasharray="31.4 31.4" transform="rotate(-90 25 25)">
        <animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="1s" repeatCount="indefinite"/>
      </circle>
    </svg>
    <div style="color:#3498db;font-weight:500;margin-top:8px;">Loading...</div>
  </div>
  <div id="graphContainer" style="display:none;max-width:95%;margin:0 auto 20px auto;">
    <div id="graphActions" style="display:flex;align-items:center;justify-content:flex-end;margin-bottom:8px;"></div>
    <canvas id="resultsChart"></canvas>
  </div>
  <div id="statsContainer" style="display:none;max-width:95%;margin:0 auto 20px auto;"></div>
  <div id="qcContainer" style="display:none;max-width:95%;margin:0 auto 40px auto;"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    /* ===== Render chart instantly: disable all Chart.js animations ===== */
    if (window.Chart && Chart.defaults) {
      Chart.defaults.animation = false;
      if (Chart.defaults.transitions && Chart.defaults.transitions.active) {
        Chart.defaults.transitions.active.animation = false;
      }
    }

    // Configuration for this page
    const STATIONS = ['DAGF','DBKB','DBLK','DBNG','DBRG','DCHI','DCLY','DDFS','DFHM','DGES',
'DGLW','DGUM','DHAR','DHOC','DJCR','DLAU','DMIL','DNEM','DNOT','DPPN',
'DRHB','DSCR','DSGM','DSJR','DSLB','DSND','DTDF','DWAR','DWBD','DWCH',
'DWHW','DWPK','DWWK'];
    const DATA_TYPE_ID = '285'; //285=min, 284=max, 283=mean Mean Daily Barometric Pressure
    const DAYS_BACK = 30; // default window length in days

    function buildProcessUrl(station, dataType, year, month) {
      return `process.php?station=${station}&dataType=${dataType}&startYear=${year}&endYear=${year}&month=${month}`;
    }

    function showSpinner() {
      document.getElementById("loadingSpinner").style.display = "";
    }
    function hideSpinner() {
      document.getElementById("loadingSpinner").style.display = "none";
    }

    let lastSeries = null; // { [station]: array<{date, value}> }
    let lastLabels = null; // array of dates aligned to lastSeries entries
    let paramMeta = { label: 'Mean Daily Barometric Pressure', units: 'mb' };
    let chartInstance = null;
    let stationQC = {}; // station -> { category, score }

    function clearGraph() {
      document.getElementById("graphContainer").style.display = "none";
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }
    }
    function clearStats() {
      document.getElementById("statsContainer").style.display = "none";
      document.getElementById("statsContainer").innerHTML = "";
    }
    // Compute date helpers
    function formatDate(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function monthsInRange(start, end) {
      const months = [];
      const cur = new Date(start.getFullYear(), start.getMonth(), 1);
      const endAnchor = new Date(end.getFullYear(), end.getMonth(), 1);
      while (cur <= endAnchor) {
        months.push({ year: cur.getFullYear(), month: String(cur.getMonth() + 1).padStart(2, '0') });
        cur.setMonth(cur.getMonth() + 1);
      }
      return months;
    }

    function getDateRange() {
      const today = new Date();
      today.setHours(0,0,0,0);
      const input = document.getElementById('startDateInput');
      const val = input && input.value ? new Date(input.value) : null;
      if (val && !isNaN(val.getTime())) {
        const start = new Date(val.getFullYear(), val.getMonth(), val.getDate());
        const end = new Date(start);
        end.setDate(start.getDate() + (DAYS_BACK - 1));
        return { start, end };
      } else {
        const end = new Date(today);
        const start = new Date(end);
        start.setDate(end.getDate() - (DAYS_BACK - 1));
        return { start, end };
      }
    }

    async function fetchLast30Days() {
      const errorMsg = document.getElementById("errorMsg");
      errorMsg.textContent = "";
      clearGraph();
      clearStats();
      showSpinner();

      // Range (either entered start date or last DAYS_BACK days)
      const { start, end } = getDateRange();

      // Lookup param meta (label/units)
      try {
        const plist = await fetch('parameters.json').then(r => r.json());
        const meta = plist.find(p => String(p.data_type_id) === DATA_TYPE_ID);
        if (meta) {
          paramMeta = { label: meta.display_name, units: meta.display_units };
          // Update H1 with units if present
          const h1 = document.querySelector('h1');
          if (h1) {
            const rangeTxt = `${formatDate(start)} to ${formatDate(end)}`;
            h1.textContent = `${STATIONS.join(', ')} — ${paramMeta.label} (${paramMeta.units}) — ${rangeTxt}`;
          }
        }
      } catch (_) { /* non-fatal */ }
      // Fetch extended range (previous 6 days) to compute 7-day score history
      const extStart = new Date(start);
      extStart.setDate(extStart.getDate() - 6);
      const months = monthsInRange(extStart, end);

      // Fetch data for all stations in parallel
      const stationData = await Promise.all(
        STATIONS.map(async (station) => {
          const maps = await Promise.all(months.map(async (m) => {
            const url = buildProcessUrl(station, DATA_TYPE_ID, m.year, m.month);
            try {
              const text = await fetch(url).then(r => r.text());
              const data = text ? JSON.parse(text) : { results: [] };
              return Array.isArray(data.results) ? data.results : [];
            } catch (e) {
              // Non-fatal; return empty set for this month
              return [];
            }
          }));
          // Flatten and build date->value map
          const map = new Map();
          maps.flat().forEach(item => {
            const dstr = (item.date || '').slice(0, 10);
            if (!dstr) return;
            map.set(dstr, item.value);
          });
          return { station, map };
        })
      );

      // Build aligned date labels and per-station series
      const labels = [];
      const seriesByStation = {};
      const cursor = new Date(start);
      while (cursor <= end) {
        const dstr = formatDate(cursor);
        labels.push(dstr);
        cursor.setDate(cursor.getDate() + 1);
      }
      for (const { station, map } of stationData) {
        seriesByStation[station] = labels.map(dstr => {
          let v = map.has(dstr) ? map.get(dstr) : "--";
          if (v !== "--" && v !== null && v !== undefined && !isNaN(v)) {
            v = Number(v);
          } else {
            v = "--";
          }
          return { date: dstr, value: v };
        });
      }

      lastLabels = labels;
      lastSeries = seriesByStation;
      hideSpinner();
      renderStats();
      renderQualityChecks();
      renderGraph();
    }

    function renderStats() {
      const statsDiv = document.getElementById("statsContainer");
      statsDiv.innerHTML = "";
      if (!lastSeries || Object.keys(lastSeries).length === 0) {
        statsDiv.style.display = "";
        statsDiv.innerHTML = "<div style='color:#c0392b;font-weight:500;'>No data found.</div>";
        return;
      }
      let html = "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);margin-bottom:30px;'>";
      html += "<thead><tr>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station / Parameter</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Count</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Missing</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Min</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Mean</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Max</th>";
      html += "</tr></thead><tbody>";
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        const nums = series.map(d => d.value).filter(v => v !== "--" && !isNaN(v));
        const count = nums.length;
        const missing = series.length - count;
        let min = "--", max = "--", mean = "--";
        if (count > 0) {
          min = Math.min(...nums);
          max = Math.max(...nums);
          mean = (nums.reduce((a, b) => a + b, 0) / count).toFixed(2);
        }
        const label = `${station}: ${paramMeta.label} (${paramMeta.units})`;
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${label}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${count}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${missing}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${min}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${mean}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${max}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      statsDiv.style.display = "";
      statsDiv.innerHTML = html;
    }

    function renderGraph() {
      if (!lastSeries || !lastLabels || Object.keys(lastSeries).length === 0) return;
      const labels = lastLabels;
      const ctx = document.getElementById('resultsChart').getContext('2d');
      clearGraph();

      function colorForCategory(cat) {
        switch (cat) {
          case 'Minimal concern': return '#f1c40f'; // yellow
          case 'Possible concern': return '#f39c12'; // orange
          case 'Potential issue': return '#e74c3c'; // red
          default: return '#bfc9d1'; // light grey
        }
      }

      const datasets = STATIONS.map((station) => {
        const series = lastSeries[station] || [];
        const data = series.map(d => (d.value === "--" || isNaN(d.value)) ? null : Number(d.value));
        const cat = (stationQC[station] && stationQC[station].category) ? stationQC[station].category : 'No concern';
        const color = colorForCategory(cat);
        return {
          label: station,
          data,
          borderColor: color,
          backgroundColor: color + '33',
          spanGaps: false,
          pointRadius: 2,
          tension: 0.2
        };
      });
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
          responsive: true,
          animation: false,
          plugins: {
            legend: { display: true, position: 'top' },
            title: { display: false }
          },
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: { display: true, title: { display: true, text: 'Date' } },
            y: { display: true, title: { display: true, text: paramMeta.units || 'Value' } }
          }
        }
      });
      document.getElementById("graphContainer").style.display = "";
    }

    // Allow manual range application
    document.getElementById('applyRangeBtn').addEventListener('click', () => {
      fetchLast30Days();
    });

    // Auto-run on load
    window.addEventListener('DOMContentLoaded', fetchLast30Days);

    // ===== Quality Control Rendering =====
    function scoreCategory(score) {
      if (score >= 90) return 'No concern';
      if (score >= 80) return 'Minimal concern';
      if (score >= 70) return 'Possible concern';
      return 'Potential issue';
    }

    function regressionStats(xs, ys) {
      // Returns {slope, intercept, se_slope, t_slope, n, sxx}
      const n = xs.length;
      if (n < 2) return { slope: 0, intercept: 0, se_slope: Infinity, t_slope: 0, n: n, sxx: 0 };
      let sumx = 0, sumy = 0, sumxy = 0, sumx2 = 0;
      for (let i = 0; i < n; i++) { sumx += xs[i]; sumy += ys[i]; sumxy += xs[i]*ys[i]; sumx2 += xs[i]*xs[i]; }
      const denom = n * sumx2 - sumx * sumx;
      if (Math.abs(denom) < 1e-12) return { slope: 0, intercept: 0, se_slope: Infinity, t_slope: 0, n: n, sxx: 0 };
      const slope = (n*sumxy - sumx*sumy) / denom;
      const intercept = (sumy - slope*sumx) / n;
      // Residual standard error
      let sse = 0;
      for (let i = 0; i < n; i++) {
        const yhat = intercept + slope*xs[i];
        const e = ys[i] - yhat;
        sse += e*e;
      }
      const df = Math.max(1, n - 2);
      const s2 = sse / df;
      const xbar = sumx / n;
      const sxx = xs.reduce((acc,x)=>acc + (x - xbar)*(x - xbar), 0);
      const se_slope = sxx > 0 ? Math.sqrt(s2 / sxx) : Infinity;
      const t_slope = (se_slope && isFinite(se_slope) && se_slope > 0) ? slope / se_slope : 0;
      return { slope, intercept, se_slope, t_slope, n, sxx };
    }

    function mean(arr) { return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }
    function stddev(arr) {
      if (arr.length < 2) return 0;
      const m = mean(arr);
      const v = arr.reduce((s,x)=>s+(x-m)*(x-m),0)/(arr.length-1);
      return Math.sqrt(v);
    }
    function median(arr) {
      const a = arr.filter(v => v !== null && !isNaN(v)).slice().sort((x,y)=>x-y);
      const n = a.length;
      if (!n) return NaN;
      const mid = Math.floor(n/2);
      return n % 2 ? a[mid] : (a[mid-1] + a[mid]) / 2;
    }

    function renderQualityChecks() {
      const container = document.getElementById('qcContainer');
      container.innerHTML = '';
      if (!lastSeries || !lastLabels) { container.style.display = 'none'; return; }

      // Build station -> numeric array aligned to labels (null for missing)
      const stationNums = {};
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        stationNums[station] = series.map(d => (d && d.value !== "--" && !isNaN(d.value)) ? Number(d.value) : null);
      }

      // ===== New QC computation (overrides legacy logic below) =====
      /* (function runNewQC(){
        // Test 1: Mean difference vs peers on days station has data (MAR)
        const test1 = {}; // station -> {MAR, meanStation, meanPeers, nDays}
        for (const station of STATIONS) {
          let sumAbs = 0; let nDays = 0; let sumStation = 0; let sumPeers = 0; let nPeersDays = 0;
          for (let i = 0; i < lastLabels.length; i++) {
            const vi = stationNums[station][i];
            if (vi === null) continue; // only evaluate on days with station value
            const peers = [];
            for (const s2 of STATIONS) {
              if (s2 === station) continue;
              const v2 = stationNums[s2][i];
              if (v2 !== null) peers.push(v2);
            }
            if (peers.length === 0) continue; // need at least one peer that day
            // Use median of peers for robustness against outliers
            const mPeers = median(peers);
            sumAbs += Math.abs(vi - mPeers);
            nDays++;
            sumStation += vi;
            sumPeers += mPeers;
            nPeersDays++;
          }
          const MAR = nDays > 0 ? sumAbs / nDays : 0;
          const meanStation = nDays > 0 ? sumStation / nDays : 0;
          const meanPeers = nPeersDays > 0 ? sumPeers / nPeersDays : 0;
          test1[station] = { MAR, meanStation, meanPeers, nDays };
        }

        // Trend test removed per request.

        // Build table
        let html = "<h2 style='color:#2c3e50;margin:10px 0 10px 0;'>Quality Control</h2>";
        html += "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);'>";
        html += "<thead><tr>"+
                "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station</th>"+
                "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Diff Score</th>"+
                "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Last 7 Days</th>"+
                "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Diff Detail</th>"+
                "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Category</th>"+
                "</tr></thead><tbody>";

        function scoreBadge(score) {
          let bg = '#2ecc71';
          if (score < 70) bg = '#e74c3c';
          else if (score < 80) bg = '#f39c12';
          else if (score < 90) bg = '#f1c40f';
          return `<span style="display:inline-block;padding:4px 8px;border-radius:12px;color:#fff;background:${bg};min-width:38px;text-align:center;">${score}</span>`;
        }

        for (const station of STATIONS) {
          const t1 = test1[station];
          // MAR-based scoring with piecewise penalty: 0 up to 1 mb, small 1–2 mb, steeper >2 mb
          // MAR-based scoring: 20 points per mb beyond 1 mb grace
          (function(){
            const mar = (t1.MAR || 0);
            let penalty = 0;
            if (mar > 1) {
              penalty = 20 * (mar - 1);
            }
            var s = Math.round(100 - penalty);
            s = Math.max(1, Math.min(100, s));
            score1 = s;
          })();
          const avgDetail = `mean=${t1.meanStation.toFixed(2)} ${paramMeta.units}, peers=${t1.meanPeers.toFixed(2)} ${paramMeta.units}, MAR=${t1.MAR.toFixed(2)} ${paramMeta.units}, days=${t1.nDays}`;
          const overall = score1;
          const cat = scoreCategory(overall);
          stationQC[station] = { category: cat, score: overall };

          // Build last 7 daily scores (rolling window ending each day)
          const last7 = [];
          for (let offset = 0; offset < 7; offset++) {
            const endK = new Date(mainRange.end); endK.setDate(endK.getDate() - offset);
            const startK = new Date(endK); startK.setDate(endK.getDate() - (DAYS_BACK - 1));
            const res = computeMarScoreForWindow(station, startK, endK);
            last7.unshift({ date: formatDate(endK), score: (res ? res.score : null) });
          }
          function scoreToColor(sc) {
            if (sc === null || sc === undefined) return '#bdc3c7';
            if (sc >= 90) return '#2ecc71';
            if (sc >= 80) return '#f1c40f';
            if (sc >= 70) return '#f39c12';
            return '#e74c3c';
          }
          const boxes = last7.map(s => `<span title="${s.date}: ${s.score ?? 'NA'}" style="display:inline-block;width:14px;height:14px;border-radius:3px;background:${scoreToColor(s.score)};margin-right:4px;border:1px solid rgba(0,0,0,0.06);"></span>`).join('');

          html += `<tr>
            <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${station}</td>
            <td style='padding:10px 8px;border:1px solid #e1e8ed;'><span class="score-click" data-station="${station}" style="cursor:pointer;">${scoreBadge(score1)}</span></td>
            <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${avgDetail}</td>
            <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${cat}</td>
          </tr>`;
        }
        html += "</tbody></table>";
        container.innerHTML = html;
        container.style.display = '';
        // Click to open 7-day score history
        container.addEventListener('click', async (e) => {
          const t = e.target.closest('.score-click');
          if (!t) return;
          const st = t.getAttribute('data-station');
          if (!st) return;
          await showScoreHistoryModal(st);
        });
        return; // don't run legacy QC below
      })();
      return;
      */

      // Test 1: Mean difference vs peers on days the station has data (MAR)
      const test1 = {}; // station -> {MAR, meanStation, meanPeers, nDays}
      for (const station of STATIONS) {
        let sumAbs = 0; let nDays = 0; let sumStation = 0; let sumPeers = 0; let nPeersDays = 0;
        for (let i = 0; i < lastLabels.length; i++) {
          const vi = stationNums[station][i];
          if (vi === null) continue; // only evaluate on days with station value
          const peers = [];
          for (const s2 of STATIONS) {
            if (s2 === station) continue;
            const v2 = stationNums[s2][i];
            if (v2 !== null) peers.push(v2);
          }
          if (peers.length === 0) continue; // need at least one peer that day
          const mPeers = mean(peers);
          sumAbs += Math.abs(vi - mPeers);
          nDays++;
          sumStation += vi;
          sumPeers += mPeers;
          nPeersDays++;
        }
        const MAR = nDays > 0 ? sumAbs / nDays : 0;
        const meanStation = nDays > 0 ? sumStation / nDays : 0;
        const meanPeers = nPeersDays > 0 ? sumPeers / nPeersDays : 0;
        test1[station] = { MAR, meanStation, meanPeers, nDays };
      }

      // Backfill legacy fields so the original test results table renders as before
      for (const station of STATIONS) {
        const t = test1[station];
        if (!t) continue;
        t.meanAll = (typeof t.meanPeers === 'number') ? t.meanPeers : 0;
        t.delta = Math.abs((t.meanStation || 0) - (t.meanAll || 0));
        t.n = t.nDays || 0;
      }

      // Test 2: Trend inconsistency — slope of residual (station - mean of others) over time
      const test2 = {}; // station -> {slope, tSlope, n, deltaWindow}
      for (const station of STATIONS) {
        const xs = []; const ys = [];
        for (let i = 0; i < lastLabels.length; i++) {
          const vi = stationNums[station][i];
          if (vi === null) continue;
          const others = [];
          for (const s2 of STATIONS) {
            if (s2 === station) continue;
            const v2 = stationNums[s2][i];
            if (v2 !== null) others.push(v2);
          }
          if (others.length === 0) continue;
          const mOther = mean(others);
          xs.push(i);
          ys.push(vi - mOther); // residual separation from group
        }
        const stats = regressionStats(xs, ys);
        const deltaWindow = stats.slope * (Math.max(0, lastLabels.length - 1));
        test2[station] = { slope: stats.slope, tSlope: Math.abs(stats.t_slope || 0), n: stats.n, deltaWindow };
      }

      // Build table
      let html = "<h2 style='color:#2c3e50;margin:10px 0 10px 0;'>Quality Control</h2>";
      html += "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);'>";
      html += "<thead><tr>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Avg Diff Score</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Avg Diff Detail</th>"+
              
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Overall</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Category</th>"+
              "</tr></thead><tbody>";

      function scoreBadge(score) {
        let bg = '#2ecc71'; // green
        if (score < 70) bg = '#e74c3c';
        else if (score < 80) bg = '#f39c12';
        else if (score < 90) bg = '#f1c40f';
        return `<span style="display:inline-block;padding:4px 8px;border-radius:12px;color:#fff;background:${bg};min-width:38px;text-align:center;">${score}</span>`;
      }

      for (const station of STATIONS) {
        const t1 = test1[station];
        // Average diff scoring: <=2 mb is fully OK; subtract 20 pts per mb beyond 2
        const score1 = Math.max(1, Math.min(100, Math.round(100 - 20 * Math.max(0, (t1.delta || 0) - 2))))
        const avgDetail = `mean=${t1.meanStation.toFixed(2)} ${paramMeta.units}, overall=${t1.meanAll.toFixed(2)} ${paramMeta.units}, Δ=${t1.delta.toFixed(2)} ${paramMeta.units}, n=${t1.n}`;

        const t2 = { deltaWindow: 0, slope: 0, tSlope: 0, n: 0 };
        // Trend scoring: combine effect size over window and t-like statistic
        // const effectPenalty = Math.max(0, Math.abs(t2.deltaWindow || 0) - 2); // allow ~2 mb over window
        // const statPenalty = Math.max(0, (t2.tSlope || 0) - 2); // allow |t| up to ~2
        // const score2 = Math.max(1, Math.min(100, Math.round(100 - 15*effectPenalty - 7*statPenalty)));
        const trendDetail = `Δ30d=${(t2.deltaWindow||0).toFixed(2)} ${paramMeta.units}, slope=${(t2.slope||0).toExponential(2)} ${paramMeta.units}/day, |t|=${(t2.tSlope||0).toFixed(2)}, n=${t2.n}`;

        const overall = score1;
        const cat = scoreCategory(overall);
        stationQC[station] = { category: cat, score: overall };
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${station}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${scoreBadge(score1)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${avgDetail}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;font-weight:600;'>${scoreBadge(overall)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${cat}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      container.innerHTML = html;
      container.style.display = '';
    }
  </script>
</body>
</html>
