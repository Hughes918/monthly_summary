<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Monthly Summary Sandbox</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f9fa;
      margin: 0;
      padding: 0;
    }
    h1 {
      text-align: center;
      margin-top: 30px;
      color: #2c3e50;
    }
    .controls {
      margin: 30px auto 0 auto;
      padding: 20px 30px 10px 30px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      max-width: 1100px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px 20px;
    }
    .controls label {
      font-weight: 500;
      color: #34495e;
      margin-bottom: 0;
    }
    .controls input[type="text"], .controls select {
      padding: 7px 10px;
      border: 1px solid #bfc9d1;
      border-radius: 4px;
      font-size: 1em;
      background: #fafdff;
      min-width: 120px;
      margin-bottom: 0;
    }
    .controls button {
      background: #3498db;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 9px 20px;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      margin-bottom: 0;
      transition: background 0.2s;
    }
    .controls button:disabled {
      background: #bfc9d1;
      color: #fff;
      cursor: not-allowed;
    }
    .controls button:not(:last-child) {
      margin-right: 8px;
    }
    .controls button:hover:not(:disabled) {
      background: #217dbb;
    }
    #paramContainer label {
      margin-right: 5px;
    }
    #paramContainer select {
      margin-right: 15px;
    }
    .error {
      color: #c0392b;
      margin: 20px auto 0 auto;
      max-width: 900px;
      font-weight: 500;
      text-align: center;
    }
    table {
      border-collapse: collapse;
      width: 95%;
      margin: 30px auto 0 auto;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    }
    th, td {
      border: 1px solid #e1e8ed;
      padding: 10px 8px;
      text-align: left;
      font-size: 1em;
    }
    th {
      background-color: #f3f7fa;
      color: #34495e;
      font-weight: 600;
    }
    tr:nth-child(even) td {
      background: #f9fbfc;
    }
  </style>
</head>
<body>
  <h1>DAGF — Mean Daily Barometric Pressure (Last 30 Days)</h1>
  <div class="controls" style="max-width:950px;justify-content:flex-start;gap:12px 16px;">
    <label for="startDateInput">Start Date:</label>
    <input type="date" id="startDateInput" />
    <button id="applyRangeBtn">Run</button>
    <div style="font-size:0.95em;color:#566;">Leave blank to use the most recent 30 days.</div>
  </div>
  <div id="errorMsg" class="error"></div>
  <div id="loadingSpinner" style="display:none;text-align:center;margin-top:20px;">
    <svg width="48" height="48" viewBox="0 0 50 50">
      <circle cx="25" cy="25" r="20" fill="none" stroke="#3498db" stroke-width="5" stroke-linecap="round" stroke-dasharray="31.4 31.4" transform="rotate(-90 25 25)">
        <animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="1s" repeatCount="indefinite"/>
      </circle>
    </svg>
    <div style="color:#3498db;font-weight:500;margin-top:8px;">Loading...</div>
  </div>
  <div id="graphContainer" style="display:none;max-width:95%;margin:0 auto 20px auto;">
    <div id="graphActions" style="display:flex;align-items:center;justify-content:flex-end;margin-bottom:8px;"></div>
    <canvas id="resultsChart"></canvas>
  </div>
  <div id="statsContainer" style="display:none;max-width:95%;margin:0 auto 20px auto;"></div>
  <div id="qcContainer" style="display:none;max-width:95%;margin:0 auto 40px auto;"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    /* ===== Render chart instantly: disable all Chart.js animations ===== */
    if (window.Chart && Chart.defaults) {
      Chart.defaults.animation = false;
      if (Chart.defaults.transitions && Chart.defaults.transitions.active) {
        Chart.defaults.transitions.active.animation = false;
      }
    }

    // Configuration for this page
    const STATIONS = ['DAGF','DBKB','DBLK','DBNG','DBRG','DCHI','DCLY','DDFS','DFHM','DGES',
'DGLW','DGUM','DHAR','DHOC','DJCR','DLAU','DMIL','DNEM','DNOT','DPPN',
'DRHB','DSCR','DSGM','DSJR','DSLB','DSND','DTDF','DWAR','DWBD','DWCH',
'DWHW','DWPK','DWWK'];
    const DATA_TYPE_ID = '285'; //285=min, 284=max, 283=mean Mean Daily Barometric Pressure
    const DAYS_BACK = 30; // default window length in days

    function buildProcessUrl(station, dataType, year, month) {
      return `process.php?station=${station}&dataType=${dataType}&startYear=${year}&endYear=${year}&month=${month}`;
    }

    function showSpinner() {
      document.getElementById("loadingSpinner").style.display = "";
    }
    function hideSpinner() {
      document.getElementById("loadingSpinner").style.display = "none";
    }

    let lastSeries = null; // { [station]: array<{date, value}> }
    let lastLabels = null; // array of dates aligned to lastSeries entries
    let paramMeta = { label: 'Mean Daily Barometric Pressure', units: 'mb' };
    let chartInstance = null;
    let stationQC = {}; // station -> { category, score }

    function clearGraph() {
      document.getElementById("graphContainer").style.display = "none";
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }
    }
    function clearStats() {
      document.getElementById("statsContainer").style.display = "none";
      document.getElementById("statsContainer").innerHTML = "";
    }
    // Compute date helpers
    function formatDate(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function monthsInRange(start, end) {
      const months = [];
      const cur = new Date(start.getFullYear(), start.getMonth(), 1);
      const endAnchor = new Date(end.getFullYear(), end.getMonth(), 1);
      while (cur <= endAnchor) {
        months.push({ year: cur.getFullYear(), month: String(cur.getMonth() + 1).padStart(2, '0') });
        cur.setMonth(cur.getMonth() + 1);
      }
      return months;
    }

    function getDateRange() {
      const today = new Date();
      today.setHours(0,0,0,0);
      const input = document.getElementById('startDateInput');
      const val = input && input.value ? new Date(input.value) : null;
      if (val && !isNaN(val.getTime())) {
        const start = new Date(val.getFullYear(), val.getMonth(), val.getDate());
        const end = new Date(start);
        end.setDate(start.getDate() + (DAYS_BACK - 1));
        return { start, end };
      } else {
        const end = new Date(today);
        const start = new Date(end);
        start.setDate(end.getDate() - (DAYS_BACK - 1));
        return { start, end };
      }
    }

    async function fetchLast30Days() {
      const errorMsg = document.getElementById("errorMsg");
      errorMsg.textContent = "";
      clearGraph();
      clearStats();
      showSpinner();

      // Range (either entered start date or last DAYS_BACK days)
      const { start, end } = getDateRange();

      // Lookup param meta (label/units)
      try {
        const plist = await fetch('parameters.json').then(r => r.json());
        const meta = plist.find(p => String(p.data_type_id) === DATA_TYPE_ID);
        if (meta) {
          paramMeta = { label: meta.display_name, units: meta.display_units };
          // Update H1 with units if present
          const h1 = document.querySelector('h1');
          if (h1) {
            const rangeTxt = `${formatDate(start)} to ${formatDate(end)}`;
            h1.textContent = `${STATIONS.join(', ')} — ${paramMeta.label} (${paramMeta.units}) — ${rangeTxt}`;
          }
        }
      } catch (_) { /* non-fatal */ }
      // Fetch extended range (previous 6 days) to compute 7-day score history
      const extStart = new Date(start);
      extStart.setDate(extStart.getDate() - 6);
      const months = monthsInRange(extStart, end);

      // Fetch data for all stations in parallel
      const stationData = await Promise.all(
        STATIONS.map(async (station) => {
          const maps = await Promise.all(months.map(async (m) => {
            const url = buildProcessUrl(station, DATA_TYPE_ID, m.year, m.month);
            try {
              const text = await fetch(url).then(r => r.text());
              const data = text ? JSON.parse(text) : { results: [] };
              return Array.isArray(data.results) ? data.results : [];
            } catch (e) {
              // Non-fatal; return empty set for this month
              return [];
            }
          }));
          // Flatten and build date->value map
          const map = new Map();
          maps.flat().forEach(item => {
            const dstr = (item.date || '').slice(0, 10);
            if (!dstr) return;
            map.set(dstr, item.value);
          });
          return { station, map };
        })
      );

      // Build aligned date labels and per-station series
      const labels = [];
      const seriesByStation = {};
      const cursor = new Date(start);
      while (cursor <= end) {
        const dstr = formatDate(cursor);
        labels.push(dstr);
        cursor.setDate(cursor.getDate() + 1);
      }
      for (const { station, map } of stationData) {
        seriesByStation[station] = labels.map(dstr => {
          let v = map.has(dstr) ? map.get(dstr) : "--";
          if (v !== "--" && v !== null && v !== undefined && !isNaN(v)) {
            v = Number(v);
          } else {
            v = "--";
          }
          return { date: dstr, value: v };
        });
      }

      lastLabels = labels;
      lastSeries = seriesByStation;
      hideSpinner();
      renderStats();
      renderQualityChecks();
      renderGraph();
    }

    function renderStats() {
      const statsDiv = document.getElementById("statsContainer");
      statsDiv.innerHTML = "";
      if (!lastSeries || Object.keys(lastSeries).length === 0) {
        statsDiv.style.display = "";
        statsDiv.innerHTML = "<div style='color:#c0392b;font-weight:500;'>No data found.</div>";
        return;
      }
      let html = "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);margin-bottom:30px;'>";
      html += "<thead><tr>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station / Parameter</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Count</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Missing</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Min</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Mean</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Max</th>";
      html += "</tr></thead><tbody>";
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        const nums = series.map(d => d.value).filter(v => v !== "--" && !isNaN(v));
        const count = nums.length;
        const missing = series.length - count;
        let min = "--", max = "--", mean = "--";
        if (count > 0) {
          min = Math.min(...nums);
          max = Math.max(...nums);
          mean = (nums.reduce((a, b) => a + b, 0) / count).toFixed(2);
        }
        const label = `${station}: ${paramMeta.label} (${paramMeta.units})`;
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${label}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${count}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${missing}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${min}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${mean}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${max}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      statsDiv.style.display = "";
      statsDiv.innerHTML = html;
    }

    function renderGraph() {
      if (!lastSeries || !lastLabels || Object.keys(lastSeries).length === 0) return;
      const labels = lastLabels;
      const ctx = document.getElementById('resultsChart').getContext('2d');
      clearGraph();

      function colorForCategory(cat) {
        switch (cat) {
          case 'Minimal concern': return '#f1c40f'; // yellow
          case 'Possible concern': return '#f39c12'; // orange
          case 'Potential issue': return '#e74c3c'; // red
          default: return '#bfc9d1'; // light grey
        }
      }

      const datasets = STATIONS.map((station) => {
        const series = lastSeries[station] || [];
        const data = series.map(d => (d.value === "--" || isNaN(d.value)) ? null : Number(d.value));
        const cat = (stationQC[station] && stationQC[station].category) ? stationQC[station].category : 'No concern';
        const color = colorForCategory(cat);
        return {
          label: station,
          data,
          borderColor: color,
          backgroundColor: color + '33',
          spanGaps: false,
          pointRadius: 2,
          tension: 0.2
        };
      });
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
          responsive: true,
          animation: false,
          plugins: {
            legend: { display: true, position: 'top' },
            title: { display: false }
          },
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: { display: true, title: { display: true, text: 'Date' } },
            y: { display: true, title: { display: true, text: paramMeta.units || 'Value' } }
          }
        }
      });
      document.getElementById("graphContainer").style.display = "";
    }

    // Allow manual range application
    document.getElementById('applyRangeBtn').addEventListener('click', () => {
      fetchLast30Days();
    });

    // Auto-run on load
    window.addEventListener('DOMContentLoaded', fetchLast30Days);

    // ===== Quality Control Rendering =====
    function scoreCategory(score) {
      if (score >= 90) return 'No concern';
      if (score >= 80) return 'Minimal concern';
      if (score >= 70) return 'Possible concern';
      return 'Potential issue';
    }

    

    function mean(arr) { return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }
    function stddev(arr) {
      if (arr.length < 2) return 0;
      const m = mean(arr);
      const v = arr.reduce((s,x)=>s+(x-m)*(x-m),0)/(arr.length-1);
      return Math.sqrt(v);
    }
    function median(arr) {
      const a = arr.filter(v => v !== null && !isNaN(v)).slice().sort((x,y)=>x-y);
      const n = a.length;
      if (!n) return NaN;
      const mid = Math.floor(n/2);
      return n % 2 ? a[mid] : (a[mid-1] + a[mid]) / 2;
    }

    function renderQualityChecks() {
      const container = document.getElementById('qcContainer');
      container.innerHTML = '';
      if (!lastSeries || !lastLabels) { container.style.display = 'none'; return; }

      // Build station -> numeric array aligned to labels (null for missing)
      const stationNums = {};
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        stationNums[station] = series.map(d => (d && d.value !== "--" && !isNaN(d.value)) ? Number(d.value) : null);
      }


      // Compute SD-based comparison stats per station
      const test1 = {}; // station -> {meanStation, meanPeers, nDays, avgAbsDiff, avgZ}
      for (const station of STATIONS) {
        let sumAbs = 0; let nDays = 0; let sumStation = 0; let sumPeers = 0; let nPeersDays = 0;
        let sumZ = 0; let nZ = 0;
        for (let i = 0; i < lastLabels.length; i++) {
          const vi = stationNums[station][i];
          if (vi === null) continue; // only evaluate on days with station value
          const peers = [];
          for (const s2 of STATIONS) {
            if (s2 === station) continue;
            const v2 = stationNums[s2][i];
            if (v2 !== null) peers.push(v2);
          }
          if (peers.length === 0) continue; // need at least one peer that day
          const mPeers = mean(peers);
          const sPeers = stddev(peers);
          const diff = Math.abs(vi - mPeers);
          sumAbs += diff;
          nDays++;
          sumStation += vi;
          sumPeers += mPeers;
          nPeersDays++;
          if (sPeers > 0) { sumZ += diff / sPeers; nZ++; }
        }
        const meanStation = nDays > 0 ? sumStation / nDays : 0;
        const meanPeers = nPeersDays > 0 ? sumPeers / nPeersDays : 0;
        const avgAbsDiff = nDays > 0 ? (sumAbs / nDays) : 0;
        const avgZ = nZ > 0 ? (sumZ / nZ) : 0;
        test1[station] = { meanStation, meanPeers, nDays, avgAbsDiff, avgZ };
      }

      // Legacy backfill removed; test now uses SD-based metrics directly.

   

      // Build table
      let html = "<h2 style='color:#2c3e50;margin:10px 0 10px 0;'>Quality Control</h2>";
      html += "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);'>";
      html += "<thead><tr>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>StdDev Score</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>StdDev Detail</th>"+
              
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Overall</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Category</th>"+
              "</tr></thead><tbody>";

      function scoreBadge(score) {
        let bg = '#2ecc71'; // green
        if (score < 70) bg = '#e74c3c';
        else if (score < 80) bg = '#f39c12';
        else if (score < 90) bg = '#f1c40f';
        return `<span style="display:inline-block;padding:4px 8px;border-radius:12px;color:#fff;background:${bg};min-width:38px;text-align:center;">${score}</span>`;
      }

      for (const station of STATIONS) {
        const t1 = test1[station];
        // SD-based scoring: average of per-day scores derived from peer mean/SD
        let score1 = 0; // will be computed below
        const avgDetail = `mean=${t1.meanStation.toFixed(2)} ${paramMeta.units}, overall=${t1.meanAll.toFixed(2)} ${paramMeta.units}, Δ=${t1.delta.toFixed(2)} ${paramMeta.units}, n=${t1.n}`;

      
        const overall = score1;
        const cat = scoreCategory(overall);
        stationQC[station] = { category: cat, score: overall };
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${station}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${scoreBadge(score1)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${avgDetail}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;font-weight:600;'>${scoreBadge(overall)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${cat}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      container.innerHTML = html;
      container.style.display = '';
    }

    // Override with SD-based QC scoring per spec
    function renderQualityChecks() {
      const container = document.getElementById('qcContainer');
      container.innerHTML = '';
      if (!lastSeries || !lastLabels) { container.style.display = 'none'; return; }

      const stationNums = {};
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        stationNums[station] = series.map(d => (d && d.value !== "--" && !isNaN(d.value)) ? Number(d.value) : null);
      }

      const test1 = {};
      for (const station of STATIONS) {
        let sumAbs = 0; let nDays = 0; let sumStation = 0; let sumPeers = 0; let nPeersDays = 0;
        let sumZ = 0; let nZ = 0;
        for (let i = 0; i < lastLabels.length; i++) {
          const vi = stationNums[station][i];
          if (vi === null) continue;
          const peers = [];
          for (const s2 of STATIONS) {
            if (s2 === station) continue;
            const v2 = stationNums[s2][i];
            if (v2 !== null) peers.push(v2);
          }
          if (peers.length === 0) continue;
          const mPeers = mean(peers);
          const sPeers = stddev(peers);
          const diff = Math.abs(vi - mPeers);
          sumAbs += diff;
          nDays++;
          sumStation += vi;
          sumPeers += mPeers;
          nPeersDays++;
          if (sPeers > 0) { sumZ += diff / sPeers; nZ++; }
        }
        const meanStation = nDays > 0 ? sumStation / nDays : 0;
        const meanPeers = nPeersDays > 0 ? sumPeers / nPeersDays : 0;
        const avgAbsDiff = nDays > 0 ? (sumAbs / nDays) : 0;
        const avgZ = nZ > 0 ? (sumZ / nZ) : 0;
        test1[station] = { meanStation, meanPeers, nDays, avgAbsDiff, avgZ };
      }

      function scoreFromDiffAndSD(diff, s) {
        if (diff <= 1) return 100;
        if (!isFinite(s) || s <= 0) return 40;
        const z = diff / s;
        if (z <= 1) return 100;
        if (z <= 2) return Math.round(100 - 10 * (z - 1));
        if (z <= 5) return Math.round(100 - 30 * (z - 2));
        return 0;
      }

      let html = "<h2 style='color:#2c3e50;margin:10px 0 10px 0;'>Quality Control</h2>";
      html += "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);'>";
      html += "<thead><tr>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>StdDev Score</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>StdDev Detail</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Overall</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Category</th>"+
              "</tr></thead><tbody>";

      function scoreBadge(score) {
        let bg = '#2ecc71';
        if (score < 70) bg = '#e74c3c';
        else if (score < 80) bg = '#f39c12';
        else if (score < 90) bg = '#f1c40f';
        return `<span style=\"display:inline-block;padding:4px 8px;border-radius:12px;color:#fff;background:${bg};min-width:38px;text-align:center;\">${score}</span>`;
      }

      for (const station of STATIONS) {
        const t1 = test1[station];
        const dailyScores = [];
        for (let i = 0; i < lastLabels.length; i++) {
          const vi = stationNums[station][i];
          if (vi === null) continue;
          const peers = [];
          for (const s2 of STATIONS) {
            if (s2 === station) continue;
            const v2 = stationNums[s2][i];
            if (v2 !== null) peers.push(v2);
          }
          if (peers.length === 0) continue;
          const mPeers = mean(peers);
          const sPeers = stddev(peers);
          const diff = Math.abs(vi - mPeers);
          dailyScores.push(scoreFromDiffAndSD(diff, sPeers));
        }
        const score1 = dailyScores.length ? Math.round(mean(dailyScores)) : 0;
        const avgDetail = `mean=${t1.meanStation.toFixed(2)} ${paramMeta.units}, peers=${t1.meanPeers.toFixed(2)} ${paramMeta.units}, avg|diff|=${t1.avgAbsDiff.toFixed(2)} ${paramMeta.units}, avgZ=${t1.avgZ.toFixed(2)}, days=${t1.nDays}`;

        const overall = score1;
        const cat = scoreCategory(overall);
        stationQC[station] = { category: cat, score: overall };
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${station}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${scoreBadge(score1)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${avgDetail}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;font-weight:600;'>${scoreBadge(overall)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${cat}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      container.innerHTML = html;
      container.style.display = '';
    }
  </script>
</body>
</html>
