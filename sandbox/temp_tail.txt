      renderQualityChecks();
    }

    function renderStats() {
      const statsDiv = document.getElementById("statsContainer");
      statsDiv.innerHTML = "";
      if (!lastSeries || Object.keys(lastSeries).length === 0) {
        statsDiv.style.display = "";
        statsDiv.innerHTML = "<div style='color:#c0392b;font-weight:500;'>No data found.</div>";
        return;
      }
      let html = "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);margin-bottom:30px;'>";
      html += "<thead><tr>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station / Parameter</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Count</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Missing</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Min</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Mean</th>";
      html += "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Max</th>";
      html += "</tr></thead><tbody>";
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        const nums = series.map(d => d.value).filter(v => v !== "--" && !isNaN(v));
        const count = nums.length;
        const missing = series.length - count;
        let min = "--", max = "--", mean = "--";
        if (count > 0) {
          min = Math.min(...nums);
          max = Math.max(...nums);
          mean = (nums.reduce((a, b) => a + b, 0) / count).toFixed(2);
        }
        const label = `${station}: ${paramMeta.label} (${paramMeta.units})`;
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${label}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${count}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${missing}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${min}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${mean}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${max}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      statsDiv.style.display = "";
      statsDiv.innerHTML = html;
    }

    function renderGraph() {
      if (!lastSeries || !lastLabels || Object.keys(lastSeries).length === 0) return;
      const labels = lastLabels;
      const ctx = document.getElementById('resultsChart').getContext('2d');
      clearGraph();

      const colorList = [
        '#3498db', '#e67e22', '#2ecc71', '#e74c3c',
        '#9b59b6', '#16a085', '#34495e', '#f39c12'
      ];
      const datasets = STATIONS.map((station, idx) => {
        const series = lastSeries[station] || [];
        const data = series.map(d => (d.value === "--" || isNaN(d.value)) ? null : Number(d.value));
        const color = colorList[idx % colorList.length];
        return {
          label: station,
          data,
          borderColor: color,
          backgroundColor: color + '33',
          spanGaps: true,
          pointRadius: 2,
          tension: 0.2
        };
      });
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
          responsive: true,
          animation: false,
          plugins: {
            legend: { display: true, position: 'top' },
            title: { display: false }
          },
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: { display: true, title: { display: true, text: 'Date' } },
            y: { display: true, title: { display: true, text: paramMeta.units || 'Value' } }
          }
        }
      });
      document.getElementById("graphContainer").style.display = "";
    }

    // Auto-run on load
    window.addEventListener('DOMContentLoaded', fetchLast30Days);

    // ===== Quality Control Rendering =====
    function scoreCategory(score) {
      if (score >= 90) return 'No concern';
      if (score >= 80) return 'Minimal concern';
      if (score >= 70) return 'Possible concern';
      return 'Potential issue';
    }

    function regressionStats(xs, ys) {
      // Returns {slope, intercept, se_slope, t_slope, n, sxx}
      const n = xs.length;
      if (n < 2) return { slope: 0, intercept: 0, se_slope: Infinity, t_slope: 0, n: n, sxx: 0 };
      let sumx = 0, sumy = 0, sumxy = 0, sumx2 = 0;
      for (let i = 0; i < n; i++) { sumx += xs[i]; sumy += ys[i]; sumxy += xs[i]*ys[i]; sumx2 += xs[i]*xs[i]; }
      const denom = n * sumx2 - sumx * sumx;
      if (Math.abs(denom) < 1e-12) return { slope: 0, intercept: 0, se_slope: Infinity, t_slope: 0, n: n, sxx: 0 };
      const slope = (n*sumxy - sumx*sumy) / denom;
      const intercept = (sumy - slope*sumx) / n;
      // Residual standard error
      let sse = 0;
      for (let i = 0; i < n; i++) {
        const yhat = intercept + slope*xs[i];
        const e = ys[i] - yhat;
        sse += e*e;
      }
      const df = Math.max(1, n - 2);
      const s2 = sse / df;
      const xbar = sumx / n;
      const sxx = xs.reduce((acc,x)=>acc + (x - xbar)*(x - xbar), 0);
      const se_slope = sxx > 0 ? Math.sqrt(s2 / sxx) : Infinity;
      const t_slope = (se_slope && isFinite(se_slope) && se_slope > 0) ? slope / se_slope : 0;
      return { slope, intercept, se_slope, t_slope, n, sxx };
    }

    function mean(arr) { return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }
    function stddev(arr) {
      if (arr.length < 2) return 0;
      const m = mean(arr);
      const v = arr.reduce((s,x)=>s+(x-m)*(x-m),0)/(arr.length-1);
      return Math.sqrt(v);
    }

    function renderQualityChecks() {
      const container = document.getElementById('qcContainer');
      container.innerHTML = '';
      if (!lastSeries || !lastLabels) { container.style.display = 'none'; return; }

      // Build station -> numeric array aligned to labels (null for missing)
      const stationNums = {};
      for (const station of STATIONS) {
        const series = lastSeries[station] || [];
        stationNums[station] = series.map(d => (d && d.value !== "--" && !isNaN(d.value)) ? Number(d.value) : null);
      }

      // Test 1: Mean difference vs overall mean (practical thresholding)
      const test1 = {}; // station -> {delta, meanStation, meanAll, n}
      // Build overall mean from all numeric values across all stations
      const allVals = [];
      for (const s of STATIONS) {
        for (const v of stationNums[s]) { if (v !== null) allVals.push(v); }
      }
      const overallMean = mean(allVals);
      for (const station of STATIONS) {
        const vals = stationNums[station].filter(v => v !== null);
        const meanStation = mean(vals);
        const delta = Math.abs(meanStation - overallMean);
        const n = vals.length;
        test1[station] = { delta, meanStation, meanAll: overallMean, n };
      }

      // Test 2: Trend inconsistency — slope of residual (station - mean of others) over time
      const test2 = {}; // station -> {slope, tSlope, n, deltaWindow}
      for (const station of STATIONS) {
        const xs = []; const ys = [];
        for (let i = 0; i < lastLabels.length; i++) {
          const vi = stationNums[station][i];
          if (vi === null) continue;
          const others = [];
          for (const s2 of STATIONS) {
            if (s2 === station) continue;
            const v2 = stationNums[s2][i];
            if (v2 !== null) others.push(v2);
          }
          if (others.length === 0) continue;
          const mOther = mean(others);
          xs.push(i);
          ys.push(vi - mOther); // residual separation from group
        }
        const stats = regressionStats(xs, ys);
        const deltaWindow = stats.slope * (Math.max(0, lastLabels.length - 1));
        test2[station] = { slope: stats.slope, tSlope: Math.abs(stats.t_slope || 0), n: stats.n, deltaWindow };
      }

      // Build table
      let html = "<h2 style='color:#2c3e50;margin:10px 0 10px 0;'>Quality Control</h2>";
      html += "<table style='width:100%;border-collapse:collapse;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.07);'>";
      html += "<thead><tr>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Station</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Avg Diff Score</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Avg Diff Detail</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Trend Score</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Trend Detail</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Overall</th>"+
              "<th style='padding:10px 8px;border:1px solid #e1e8ed;'>Category</th>"+
              "</tr></thead><tbody>";

      function scoreBadge(score) {
        let bg = '#2ecc71'; // green
        if (score < 70) bg = '#e74c3c';
        else if (score < 80) bg = '#f39c12';
        else if (score < 90) bg = '#f1c40f';
        return `<span style="display:inline-block;padding:4px 8px;border-radius:12px;color:#fff;background:${bg};min-width:38px;text-align:center;">${score}</span>`;
      }

      for (const station of STATIONS) {
        const t1 = test1[station];
        const t2 = test2[station];
        // Average diff scoring: <=2 mb is fully OK; subtract 20 pts per mb beyond 2
        const score1 = Math.max(1, Math.min(100, Math.round(100 - 20 * Math.max(0, (t1.delta || 0) - 2))))
        const avgDetail = `mean=${t1.meanStation.toFixed(2)} ${paramMeta.units}, overall=${t1.meanAll.toFixed(2)} ${paramMeta.units}, Δ=${t1.delta.toFixed(2)} ${paramMeta.units}, n=${t1.n}`;

        // Trend scoring: combine effect size over window and t-like statistic
        const effectPenalty = Math.max(0, Math.abs(t2.deltaWindow || 0) - 2); // allow ~2 mb over window
        const statPenalty = Math.max(0, (t2.tSlope || 0) - 2); // allow |t| up to ~2
        const score2 = Math.max(1, Math.min(100, Math.round(100 - 15*effectPenalty - 7*statPenalty)));
        const trendDetail = `Δ30d=${(t2.deltaWindow||0).toFixed(2)} ${paramMeta.units}, slope=${(t2.slope||0).toExponential(2)} ${paramMeta.units}/day, |t|=${(t2.tSlope||0).toFixed(2)}, n=${t2.n}`;

        const overall = Math.min(score1, score2);
        const cat = scoreCategory(overall);
        html += `<tr>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${station}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${scoreBadge(score1)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${avgDetail}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${scoreBadge(score2)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${trendDetail}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;font-weight:600;'>${scoreBadge(overall)}</td>
          <td style='padding:10px 8px;border:1px solid #e1e8ed;'>${cat}</td>
        </tr>`;
      }
      html += "</tbody></table>";
      container.innerHTML = html;
      container.style.display = '';
    }
  </script>
</body>
</html>
